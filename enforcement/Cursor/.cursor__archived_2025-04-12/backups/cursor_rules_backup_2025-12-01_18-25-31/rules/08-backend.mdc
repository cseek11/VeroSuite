---
description: "Backend architecture: NestJS, Prisma, controller-service-DTO patterns"
globs: "apps/*/src/**/*.ts,libs/common/**/*.ts"
alwaysApply: false
---
<!-- @version: 2.0 @owner: backend-team -->

# BACKEND ARCHITECTURE (NESTJS + PRISMA)

## PURPOSE
Enforce clean NestJS architecture, safe Prisma usage, and consistent backend patterns.

---

## MODULE STRUCTURE
- **Controllers**
  - Thin; handle HTTP/transport only.
  - No business logic.
  - Use DTOs for request bodies.
  - Use `@UseGuards(JwtAuthGuard)` and RBAC decorators.
- **Services**
  - Contain business logic.
  - Use injected repositories/Prisma service.
  - Implement state transitions and invariants.
- **DTOs**
  - Co-located with feature modules (`dto/*.ts`).
  - Use `class-validator` or Zod.
  - No `any` types.

---

## PRISMA USAGE
- All tenant-scoped queries must:
  - Include tenant filters **or**
  - Rely on RLS with the correct session context.
- Multi-step operations must use `prisma.$transaction`.
- Avoid raw SQL unless performance-critical and justified.

---

## TESTING
- Every non-trivial service method should have unit tests.
- Controllers should have integration tests for:
  - Validation
  - Auth/RBAC
  - Basic happy/error paths

---

## ENFORCEMENT PIPELINE INTEGRATION

**Step 1:** Search for existing modules/services for similar features.

**Step 3:** Check:
- Controllers are thin and delegate to services.
- DTOs exist and validate inputs.
- Tenant isolation enforced according to `03-security.mdc`.
- Transactions used where needed.

**Step 5:** Audit touched files for:
- Business logic in controllers
- DTO/validation gaps
- Missing tests for new logic

---

## VIOLATIONS (HARD STOP)
- Business logic implemented in controllers.
- Tenant-scoped queries without tenant filters.
- Multi-table writes without transactions.
- Endpoints with no DTO/validation.

---

## Step 5: Post-Implementation Audit for Backend Patterns

### R11: Backend Patterns — Audit Procedures

**For code changes affecting NestJS controllers, services, DTOs, or Prisma usage:**

#### Controller Patterns

- [ ] **MANDATORY:** Verify controller is thin (handles HTTP/transport only)
- [ ] **MANDATORY:** Verify controller has no business logic (delegates to service)
- [ ] **MANDATORY:** Verify controller uses DTOs for request bodies
- [ ] **MANDATORY:** Verify controller uses `@UseGuards(JwtAuthGuard)` for protected endpoints
- [ ] **MANDATORY:** Verify controller uses RBAC decorators when needed
- [ ] **MANDATORY:** Verify controller methods delegate to service methods
- [ ] **MANDATORY:** Verify controller uses proper HTTP decorators (`@Get()`, `@Post()`, `@Put()`, `@Delete()`)
- [ ] **MANDATORY:** Verify controller uses Swagger decorators (`@ApiTags()`, `@ApiOperation()`, `@ApiResponse()`)
- [ ] **RECOMMENDED:** Verify controller uses interceptors when needed (idempotency, logging)

#### Service Patterns

- [ ] **MANDATORY:** Verify service contains business logic (not in controller)
- [ ] **MANDATORY:** Verify service uses `@Injectable()` decorator
- [ ] **MANDATORY:** Verify service injects Prisma service (DatabaseService or PrismaService)
- [ ] **MANDATORY:** Verify service implements state transitions and invariants (if applicable)
- [ ] **MANDATORY:** Verify service methods are async and return typed results
- [ ] **MANDATORY:** Verify service uses structured logging (not console.log)
- [ ] **MANDATORY:** Verify service includes traceId in logs
- [ ] **RECOMMENDED:** Verify service uses dependency injection (constructor injection)

#### DTO Patterns

- [ ] **MANDATORY:** Verify DTOs are co-located with feature modules (`dto/*.ts`)
- [ ] **MANDATORY:** Verify DTOs use `class-validator` or Zod for validation
- [ ] **MANDATORY:** Verify DTOs have no `any` types
- [ ] **MANDATORY:** Verify DTOs use proper TypeScript types (interfaces, enums, unions)
- [ ] **MANDATORY:** Verify DTOs use Swagger decorators (`@ApiProperty()`, `@ApiPropertyOptional()`)
- [ ] **MANDATORY:** Verify DTOs validate required fields (`@IsString()`, `@IsEmail()`, etc.)
- [ ] **MANDATORY:** Verify DTOs validate optional fields (`@IsOptional()`)
- [ ] **MANDATORY:** Verify DTOs use proper validation messages
- [ ] **RECOMMENDED:** Verify DTOs extend base classes when applicable (TenantAwareDto)

#### Prisma Patterns

- [ ] **MANDATORY:** Verify tenant-scoped queries include tenant filters OR rely on RLS
- [ ] **MANDATORY:** Verify tenant isolation is enforced (tenant_id in queries or RLS context)
- [ ] **MANDATORY:** Verify multi-step operations use `prisma.$transaction()`
- [ ] **MANDATORY:** Verify transactions include all related operations
- [ ] **MANDATORY:** Verify transactions have proper error handling
- [ ] **MANDATORY:** Verify raw SQL is avoided unless performance-critical and justified
- [ ] **MANDATORY:** Verify Prisma queries use proper types (no `any`)
- [ ] **MANDATORY:** Verify Prisma queries use proper includes/selects (not fetching unnecessary data)
- [ ] **RECOMMENDED:** Verify Prisma queries use proper indexes (performance considerations)

#### Testing Patterns

- [ ] **MANDATORY:** Verify unit tests exist for non-trivial service methods
- [ ] **MANDATORY:** Verify integration tests exist for controllers (validation, auth/RBAC, happy/error paths)
- [ ] **MANDATORY:** Verify tests use proper mocking (Prisma service, dependencies)
- [ ] **MANDATORY:** Verify tests follow naming conventions (`*.spec.ts`, `*.test.ts`)
- [ ] **MANDATORY:** Verify tests follow location conventions (`__tests__/`, `test/`)
- [ ] **MANDATORY:** Verify tests cover happy paths
- [ ] **MANDATORY:** Verify tests cover error paths
- [ ] **MANDATORY:** Verify tests cover edge cases
- [ ] **RECOMMENDED:** Verify tests use proper test utilities (Test.createTestingModule)

#### Module Structure

- [ ] **MANDATORY:** Verify module follows NestJS conventions (controller, service, module files)
- [ ] **MANDATORY:** Verify module exports service (if used by other modules)
- [ ] **MANDATORY:** Verify module imports required dependencies (CommonModule, etc.)
- [ ] **MANDATORY:** Verify module registers controllers and providers
- [ ] **RECOMMENDED:** Verify module uses feature modules (not monolithic)

#### Automated Checks

```bash
# Run backend patterns checker
python .cursor/scripts/check-backend-patterns.py --file <file_path>

# Check all changed files
python .cursor/scripts/check-backend-patterns.py --pr <PR_NUMBER>

# Check specific module
python .cursor/scripts/check-backend-patterns.py --module <module_name>

# Expected: No violations found
```

#### OPA Policy

- **Policy:** `services/opa/policies/backend.rego` (R11 section)
- **Enforcement:** OVERRIDE (Tier 2 MAD) - Requires justification
- **Tests:** `services/opa/tests/backend_r11_test.rego`

#### Manual Verification (When Needed)

1. **Review Controller Structure** - Verify controller is thin and delegates to service
2. **Review Service Structure** - Verify service contains business logic and uses Prisma correctly
3. **Review DTO Structure** - Verify DTOs exist, validate inputs, and have no `any` types
4. **Review Prisma Usage** - Verify tenant isolation, transactions, and proper query patterns

**Example Controller Violation (❌):**

```typescript
// ❌ VIOLATION: Business logic in controller
@Controller('work-orders')
export class WorkOrdersController {
  @Post()
  async createWorkOrder(@Body() data: any, @Request() req: any) {
    // Business logic in controller - VIOLATION
    const customer = await this.prisma.account.findFirst({
      where: { id: data.customer_id, tenant_id: req.user.tenantId }
    });
    if (!customer) {
      throw new NotFoundException('Customer not found');
    }
    
    // More business logic...
    return await this.prisma.workOrder.create({ data });
  }
}
```

**Example Controller Correct (✅):**

```typescript
// ✅ CORRECT: Thin controller, delegates to service
@Controller('work-orders')
@UseGuards(JwtAuthGuard)
export class WorkOrdersController {
  constructor(private readonly workOrdersService: WorkOrdersService) {}

  @Post()
  @ApiOperation({ summary: 'Create a new work order' })
  @ApiResponse({ status: 201, description: 'Work order created' })
  async createWorkOrder(
    @Body() createWorkOrderDto: CreateWorkOrderDto,
    @Request() req: any
  ) {
    // Thin controller - delegates to service
    return await this.workOrdersService.createWorkOrder(
      createWorkOrderDto,
      req.user.tenantId,
      req.user.userId
    );
  }
}
```

**Example Service Violation (❌):**

```typescript
// ❌ VIOLATION: No business logic, just passes through
@Injectable()
export class WorkOrdersService {
  async createWorkOrder(data: any, tenantId: string) {
    // No validation, no business logic - VIOLATION
    return await this.prisma.workOrder.create({
      data: { ...data, tenant_id: tenantId }
    });
  }
}
```

**Example Service Correct (✅):**

```typescript
// ✅ CORRECT: Business logic in service
@Injectable()
export class WorkOrdersService {
  constructor(
    private db: DatabaseService,
    private audit: AuditService
  ) {}

  async createWorkOrder(
    data: CreateWorkOrderDto,
    tenantId: string,
    userId?: string
  ) {
    // Business logic: Validate customer exists
    const customer = await this.db.account.findFirst({
      where: { id: data.customer_id, tenant_id: tenantId }
    });
    if (!customer) {
      throw new NotFoundException('Customer not found');
    }

    // Business logic: Use transaction for multi-step operation
    return await this.db.$transaction(async (tx) => {
      const workOrder = await tx.workOrder.create({
        data: {
          tenant_id: tenantId,
          customer_id: data.customer_id,
          // ... other fields
        }
      });

      // Audit log
      await this.audit.log({
        entity: 'WorkOrder',
        entityId: workOrder.id,
        action: 'create',
        userId,
        tenantId
      });

      return workOrder;
    });
  }
}
```

**Example DTO Violation (❌):**

```typescript
// ❌ VIOLATION: No validation, uses any type
export class CreateWorkOrderDto {
  customer_id: any; // VIOLATION: any type
  // No validation decorators - VIOLATION
  description: string;
}
```

**Example DTO Correct (✅):**

```typescript
// ✅ CORRECT: Proper validation, no any types
export class CreateWorkOrderDto {
  @ApiProperty({ description: 'Customer ID', example: 'uuid-123' })
  @IsUUID('4', { message: 'Customer ID must be a valid UUID' })
  customer_id!: string;

  @ApiProperty({ description: 'Description', maxLength: 1000 })
  @IsString()
  @Length(1, 1000, { message: 'Description must be between 1 and 1000 characters' })
  description!: string;

  @ApiPropertyOptional({ description: 'Scheduled date' })
  @IsOptional()
  @IsDateString({}, { message: 'Scheduled date must be a valid date' })
  scheduled_date?: string;
}
```

**Example Prisma Violation (❌):**

```typescript
// ❌ VIOLATION: No tenant filter, no transaction
async createWorkOrderWithItems(data: CreateWorkOrderDto) {
  const workOrder = await this.prisma.workOrder.create({ data });
  // Missing tenant filter - VIOLATION
  await this.prisma.workOrderItem.createMany({ data: items });
  // No transaction - VIOLATION (multi-step operation)
}
```

**Example Prisma Correct (✅):**

```typescript
// ✅ CORRECT: Tenant filter, transaction for multi-step operation
async createWorkOrderWithItems(
  data: CreateWorkOrderDto,
  tenantId: string
) {
  return await this.prisma.$transaction(async (tx) => {
    const workOrder = await tx.workOrder.create({
      data: {
        ...data,
        tenant_id: tenantId // Tenant filter included
      }
    });

    await tx.workOrderItem.createMany({
      data: items.map(item => ({
        ...item,
        work_order_id: workOrder.id,
        tenant_id: tenantId // Tenant filter included
      }))
    });

    return workOrder;
  });
}
```

---

**Last Updated:** 2025-12-04  
**Maintained By:** Backend Team  
**Review Frequency:** Quarterly or when backend patterns change