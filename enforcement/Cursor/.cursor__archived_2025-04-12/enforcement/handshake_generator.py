#!/usr/bin/env python3
"""
Handshake File Generator for Two-Brain Model.

Generates three handshake files that Brain 1 (LLM) must read:
- ENFORCER_STATUS.md - Single source of truth for approval status
- ACTIVE_VIOLATIONS.md - Human-readable list of current violations
- ACTIVE_CONTEXT_DUMP.md - Dynamic context pushed to Brain 1

These files are generated from EnforcerReport after each enforcement run.

Last Updated: 2025-12-04
"""

from pathlib import Path
from typing import List, Optional, Tuple
from datetime import datetime, timezone

from .report_generator import EnforcerReport, Violation


class HandshakeGenerator:
    """Generate handshake files from EnforcerReport."""
    
    def __init__(self, enforcement_dir: Path):
        """
        Initialize handshake generator.
        
        Args:
            enforcement_dir: Path to .cursor/enforcement directory
        """
        self.enforcement_dir = enforcement_dir
        self.project_root = enforcement_dir.parent.parent
    
    def generate_all(self, report: EnforcerReport):
        """
        Generate all three handshake files.
        
        Args:
            report: EnforcerReport instance with violations and context
        """
        self.generate_status_file(report)
        self.generate_violations_file(report)
        self.generate_context_dump(report)
    
    def generate_status_file(self, report: EnforcerReport):
        """Generate ENFORCER_STATUS.md with approval status."""
        # For between-task checks, gate on current_session violations only
        # For full scans, gate on all violations
        blocking_current = [v for v in report.violations 
                           if v.severity == "BLOCKING" and v.session_scope == "current_session"]
        warning_current = [v for v in report.violations 
                          if v.severity == "WARNING" and v.session_scope == "current_session"]
        blocking_historical = [v for v in report.violations 
                              if v.severity == "BLOCKING" and v.session_scope != "current_session"]
        warning_historical = [v for v in report.violations 
                             if v.severity == "WARNING" and v.session_scope != "current_session"]
        
        # Determine status based on current_session violations (for fast incremental checks)
        # Historical violations are shown but don't block
        if blocking_current:
            status = "REJECTED"
            reason = f"Blocking violations detected in current session ({len(blocking_current)}). See ACTIVE_VIOLATIONS.md for details."
        elif warning_current:
            status = "WARNINGS_ONLY"
            reason = f"Only warnings present in current session ({len(warning_current)}). System is functional but improvements recommended."
        elif blocking_historical:
            status = "APPROVED_WITH_BASELINE_ISSUES"
            reason = f"Current session is clean, but {len(blocking_historical)} blocking baseline violations exist. See ACTIVE_VIOLATIONS.md for details."
        else:
            status = "APPROVED"
            reason = "No violations detected in current session. System is compliant."
        
        summary = report.get_summary()
        
        content = f"""# ENFORCER STATUS

**Status:** {status}  
**Last Scan:** {report.generated_at}  
**Session ID:** {report.session_id}

---

## Summary

### Current Session
- **Blocking Violations:** {len(blocking_current)}
- **Warning Violations:** {len(warning_current)}

### Baseline (Historical)
- **Blocking Violations:** {len(blocking_historical)}
- **Warning Violations:** {len(warning_historical)}

### Total
- **Blocking Violations:** {summary['blocking_count']}
- **Warning Violations:** {summary['warning_count']}
- **Auto-Fixes Applied:** {summary['auto_fixes_applied']}

---

## Status Details

**Note:** {reason}

**Gating:** Status is determined by current session violations. Baseline violations are shown for visibility but do not block task completion.

---

**Generated by:** VeroField Auto-Enforcer  
**Next Check:** Run `python .cursor/scripts/auto-enforcer.py --scope current_session` for incremental scan
"""
        
        self._write_file("ENFORCER_STATUS.md", content)
    
    def generate_violations_file(self, report: EnforcerReport):
        """Generate ACTIVE_VIOLATIONS.md with current violations."""
        # Separate violations by scope
        blocking_current = [v for v in report.violations 
                           if v.severity == "BLOCKING" and v.session_scope == "current_session"]
        warning_current = [v for v in report.violations 
                          if v.severity == "WARNING" and v.session_scope == "current_session"]
        blocking_historical = [v for v in report.violations 
                              if v.severity == "BLOCKING" and v.session_scope != "current_session"]
        warning_historical = [v for v in report.violations 
                             if v.severity == "WARNING" and v.session_scope != "current_session"]
        
        # Determine status based on current_session violations
        if blocking_current:
            status = "REJECTED"
        elif warning_current:
            status = "WARNINGS_ONLY"
        else:
            status = "CLEAN"
        
        content = f"""# ACTIVE VIOLATIONS — FIX NOW

**Status:** {status}  
**Last Scan:** {report.generated_at}  
**Session ID:** {report.session_id}

---

"""
        
        if not blocking_current and not warning_current and not blocking_historical and not warning_historical:
            # No violations
            content += """✅ **No active violations detected.**

System is compliant. You may proceed with new tasks.

---

**Generated by:** VeroField Auto-Enforcer
"""
        else:
            # Has violations - show current_session first (these gate task completion)
            if blocking_current or warning_current:
                content += """## Current Session Violations — Fix NOW

**These violations were introduced in the current session and must be fixed before task completion.**

"""
                if blocking_current:
                    content += f"""### Critical (BLOCKING)

"""
                    for idx, violation in enumerate(blocking_current, 1):
                        content += self._format_violation(violation, idx)
                        content += "\n"
                
                if warning_current:
                    if blocking_current:
                        content += "---\n\n"
                    content += f"""### Warnings

"""
                    start_idx = len(blocking_current) + 1
                    for idx, violation in enumerate(warning_current, start_idx):
                        content += self._format_violation(violation, idx)
                        content += "\n"
            
            # Show historical violations separately (for visibility, don't gate)
            if blocking_historical or warning_historical:
                if blocking_current or warning_current:
                    content += "\n---\n\n"
                content += """## Historical Violations (Baseline)

**These violations exist in baseline code (not from current session). They are shown for visibility but do not block task completion.**

"""
                if blocking_historical:
                    content += f"""### Critical (BLOCKING) - Historical

"""
                    start_idx = len(blocking_current) + len(warning_current) + 1
                    for idx, violation in enumerate(blocking_historical, start_idx):
                        content += self._format_violation(violation, idx)
                        content += "\n"
                
                if warning_historical:
                    if blocking_historical:
                        content += "\n"
                    content += f"""### Warnings - Historical

"""
                    start_idx = len(blocking_current) + len(warning_current) + len(blocking_historical) + 1
                    for idx, violation in enumerate(warning_historical[:10], start_idx):  # Limit to 10 for brevity
                        content += self._format_violation(violation, idx)
                        content += "\n"
                    if len(warning_historical) > 10:
                        content += f"\n*... and {len(warning_historical) - 10} more historical warnings. See `ENFORCER_REPORT.json` for complete list.*\n"
            
            content += f"""---

## Summary

### Current Session (Gates Task Completion)
- **Blocking:** {len(blocking_current)}
- **Warnings:** {len(warning_current)}
- **Action Required:** {"Fix all BLOCKING violations before proceeding" if blocking_current else "Consider fixing WARNING violations if simple" if warning_current else "None - current session is clean"}

### Baseline (Historical - For Visibility)
- **Blocking:** {len(blocking_historical)}
- **Warnings:** {len(warning_historical)}

---

**Generated by:** VeroField Auto-Enforcer  
**See Also:** `ENFORCER_REPORT.json` for full details
"""
        
        self._write_file("ACTIVE_VIOLATIONS.md", content)
    
    def generate_context_dump(self, report: EnforcerReport):
        """Generate ACTIVE_CONTEXT_DUMP.md with recommended context."""
        bundle = report.context_bundle
        task_type = bundle.get("task_type") or "general"
        hints = bundle.get("hints", [])
        relevant_files = bundle.get("relevant_files", [])[:10]  # Max 10 files
        patterns = bundle.get("patterns_to_follow", [])
        
        content = f"""# ACTIVE CONTEXT DUMP

**Generated:** {report.generated_at}  
**Task Type:** `{task_type}`  
**Session ID:** {report.session_id}

---

## Task Context

**Detected Task Type:** `{task_type}`

"""
        
        if hints:
            content += "**Hints:**\n"
            for hint in hints:
                content += f"- {hint}\n"
            content += "\n"
        else:
            content += "**Hints:**\n- No specific context hints available\n- Proceed with standard development practices\n\n"
        
        content += "---\n\n## Recommended Files\n\n"
        
        if relevant_files:
            for idx, file_path in enumerate(relevant_files, 1):
                content += f"{idx}. `{file_path}`\n"
            content += "\n"
        else:
            content += "No specific files recommended at this time.\n\n"
        
        # Extract snippets (max 5 total, max 50 lines each)
        snippets = self._extract_snippets(report, relevant_files)
        
        if snippets:
            content += "---\n\n## Code Snippets\n\n"
            for file_path, snippet_lines, line_range in snippets:
                # Detect language from file extension
                lang = self._detect_language(file_path)
                content += f"### `{file_path}` (lines {line_range[0]}-{line_range[1]})\n\n"
                content += f"```{lang}\n"
                content += snippet_lines
                content += "\n```\n\n"
        
        if patterns:
            content += "---\n\n## Patterns to Follow\n\n"
            for idx, pattern in enumerate(patterns, 1):
                content += f"{idx}. **{pattern}**\n"
                # Try to extract code example if pattern contains code-like content
                if "```" in pattern or "{" in pattern:
                    # Pattern might contain code, format it
                    content += "\n"
            content += "\n"
        
        content += """---

**Generated by:** VeroField Auto-Enforcer  
**Purpose:** This file provides minimal context hints for the current task. Read this before editing code.
"""
        
        self._write_file("ACTIVE_CONTEXT_DUMP.md", content)
    
    def _format_violation(self, violation: Violation, index: int) -> str:
        """Format a single violation for markdown."""
        content = f"""{index}. **[{violation.id}]** {violation.description}
   - **File:** `{violation.file}`
   - **Rule:** `{violation.rule_ref}`
"""
        if violation.fix_hint:
            content += f"   - **Fix Hint:** {violation.fix_hint}\n"
        
        if violation.evidence:
            content += "   - **Evidence:**\n"
            for evidence in violation.evidence[:3]:  # Max 3 evidence items
                content += f"     - {evidence}\n"
        
        return content
    
    def _extract_snippets(self, report: EnforcerReport, relevant_files: List[str]) -> List[Tuple[str, str, Tuple[int, int]]]:
        """
        Extract code snippets from relevant files.
        
        Returns:
            List of tuples: (file_path, snippet_content, (start_line, end_line))
            Max 5 snippets total, max 50 lines per snippet
        """
        snippets = []
        max_snippets = 5
        max_lines_per_snippet = 50
        
        # Prioritize files with violations
        violation_files = {v.file for v in report.violations if v.file}
        
        # Sort: violation files first, then others
        prioritized_files = sorted(
            relevant_files,
            key=lambda f: (f not in violation_files, f)
        )
        
        for file_path in prioritized_files[:max_snippets]:
            if len(snippets) >= max_snippets:
                break
            
            snippet = self._extract_snippet(file_path)
            if snippet:
                snippets.append(snippet)
        
        return snippets
    
    def _extract_snippet(self, file_path: str) -> Optional[Tuple[str, str, Tuple[int, int]]]:
        """
        Extract a code snippet from a file.
        
        Args:
            file_path: Relative path to file from project root
        
        Returns:
            Tuple of (file_path, snippet_content, (start_line, end_line)) or None
        """
        try:
            full_path = self.project_root / file_path
            if not full_path.exists():
                return None
            
            # Skip binary files
            try:
                content = full_path.read_text(encoding='utf-8')
            except (UnicodeDecodeError, PermissionError):
                return None
            
            lines = content.splitlines()
            total_lines = len(lines)
            
            if total_lines == 0:
                return None
            
            # Determine snippet range
            # If file is small, show all
            if total_lines <= 50:
                start_line = 1
                end_line = total_lines
                snippet_lines = lines
            else:
                # Show first 50 lines
                start_line = 1
                end_line = 50
                snippet_lines = lines[:50]
            
            snippet_content = "\n".join(snippet_lines)
            
            return (file_path, snippet_content, (start_line, end_line))
        
        except Exception:
            # Silently skip files that can't be read
            return None
    
    def _detect_language(self, file_path: str) -> str:
        """
        Detect programming language from file extension.
        
        Args:
            file_path: Path to file
        
        Returns:
            Language identifier for markdown code fence
        """
        ext = Path(file_path).suffix.lower()
        lang_map = {
            '.ts': 'typescript',
            '.tsx': 'typescript',
            '.js': 'javascript',
            '.jsx': 'javascript',
            '.py': 'python',
            '.prisma': 'prisma',
            '.sql': 'sql',
            '.md': 'markdown',
            '.mdc': 'markdown',
            '.json': 'json',
            '.yaml': 'yaml',
            '.yml': 'yaml',
            '.toml': 'toml',
            '.sh': 'bash',
            '.bash': 'bash',
            '.css': 'css',
            '.scss': 'scss',
            '.html': 'html',
            '.xml': 'xml',
        }
        return lang_map.get(ext, 'text')
    
    def _write_file(self, filename: str, content: str):
        """
        Write content to a file in enforcement directory.
        
        Args:
            filename: Name of file to write
            content: Content to write
        """
        file_path = self.enforcement_dir / filename
        file_path.parent.mkdir(parents=True, exist_ok=True)
        file_path.write_text(content, encoding='utf-8')

